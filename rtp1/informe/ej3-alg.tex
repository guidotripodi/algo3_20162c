A continuaci\'on se detalla el pseudo-c\'odigo de los algoritmos que resuelven el problema:

\begin{algorithm}[H] %or another one check
 \caption{BuscarMaximo}
%     \SetAlgoLined

	\For{matriz $\in$ matrices}{
    objetoActual es último objeto que no fue optimizado\\
    copiar matriz de la iteración previa a matriz\\
	entero x $\gets$	 capacidad(Mochila3)\\
	\While{x $\geq$ 0}{
		entero y $\gets$	 capacidad(Mochila2)\\	
		\While{x $\geq$ 0}{	
				entero z $\gets$	 capacidad(Mochila1)\\	
			\While{z $\geq$ 0}{
			
				entero m1 $\gets$matriz[x-pesoObjetoActual][y][z] \\	
				
				entero m2 $\gets$ matriz[x][y-pesoObjetoActual][z]\\	
				
				entero m3 $\gets$ matriz[x][y][z-pesoObjetoActual]\\	
				
				\If{objeto optimiza máximo total poniendolo en mochila1}
{para matriz[x][y][z] asignar m1 + valorObjetoActual\\
}
				\ElseIf{objeto optimiza máximo total poniendolo en mochila2}
{para matriz[x][y][z] asignar m2 + valorObjetoActual\\
}
				\ElseIf{objeto optimiza máximo total poniendolo en mochila3}{
para matriz[x][y][z] asignar m3 + valorObjetoActual\\
}
\If{matriz[x][y][z] es nuevo máximo}{
	guardar nuevo máximo y las posiciones
}
decrementar z \\
}
decrementar y \\
}
decrementar x \\
}

}

devolver obtenerMaximo

\end{algorithm}

\newpage

\begin{algorithm}[H] %or another one check
 \caption{obtenerMaximo}
%     \SetAlgoLined

\For{matrizActual $\in$ matrices}{
objetoActual es último objeto que optimizó matrizActual\\
 \If{matrizActual[x][y][z] $\neq$ matrizAnterior[x][y][z]}{
 \If{ el valor máximo obtenido viene de agregarlo en la mochila 1 de matrizAnterior}{ 
 Mochila1 $\cup$ objetoActual
 }\ElseIf{ el valor máximo obtenido viene de agregarlo en la mochila 2 de matrizAnterior}{ 
 Mochila2 $\cup$ objetoActual
 }\ElseIf{ el valor máximo obtenido viene de agregarlo en la mochila 3 de matrizAnterior}{ 
 Mochila3 $\cup$ objetoActual
}
}
}


devolver max\\
\end{algorithm}