Dado que una solución exacta al problema de nuestro entrenador pokemon es costosa, ya que debe recurrirse al backtracking por ser un problema que busca un circuito minimo en cantidad de pokeparadas pasando una sola vez por las mismas y sin repetir gimnasios. Esto es similar a buscar un camino hamiltoniano, pero sin recorrer absolutamente todos los nodos, con lo que se generan aun más combinaciones posibles.

En el punto anterior se decidió implementar una solución basada en un algoritmo goloso. Dado que la misma puede no ser exacta, nos interesa tratar de mejorar sus resultados. 

Para esto, dado que una solución es representada como una sucesion de nodos, tal que dos nodos consecutivos identifican una arista de nuestro camino, si intercambiamos el orden de ciertos nodos, estaremos modificando la solución reemplazando aristas de la solución original (De ahora en más $S_o$) y agregando nuevas a la misma. 

De esta manera existen una cierta cantidad y tipo de movimientos que podemos realizar a la que denominamos $vecindad$ de $S_o$. 
Si cada vez que observamos una vecindad, nos quedamos con la mejor solución posible en la misma y seguimos analizando los vecinos de esta, hasta que no se produzcan mejoras, podremos refinar el resultado aún más.

Esta técnica de optimización se denomina heuristica de búsqueda local.

Se denomina $k-opt$ cuando especificamente se modifican $k$ aristas de la solución. Generalmente se suele utilizar un $k$ de 2 o 3 ya que para valores mayores se pierde granularidad y por lo tanto es posible perder mejores resultados. Aunque esto último depende mucho del problema analizado y las entradas del algoritmo. Para este informe elegimos $2-opt$ y $3-opt$.

ALGUN DIBUJITO MOSTRANDO 2-OPT Y 3-OPT 

Además, realizando un simple swap de nodos, podemos obtener muy facilmente soluciones que intercambian 2 o 4 aristas. Serán dos si los nodos intercambiados de posición son consecutivos y cuatro si no lo son.

ALGUN DIBUJITO MOSTRANDO SWAP

Además tenemos que tener en cuenta para nuestro problema, que al permutar una solución con alguno de los métodos mencionados, y la solucion sea válida, pueden quedar pokeparadas al final del recorrido, por lo cual es necesario eliminarlas del mismo, ya que al considerar el recorrido hasta las mismas, se podría sumar distancia a la solución que ya no aporta, debido a que todos los gimnasios fueron derrotados. Además, podría desestimarse como solución candidata si luego se obtiene otra que tiene menor distancia solo porque se están contando pokeparadas de más.\\

HACER ALGUN DIBUJITO QUE LO REFLEJE
 
De esta manera, podremos movernos a travez del espacio de soluciones locales a $S_o$ y tal vez mejorar la solución, aunque que de esto, por ser una heuristica, no tendremos ninguna garantia.

En este punto nos centraremos en estudiar y tratar de concluir cual de las heuristicas consideradas en este punto es mejor utilizar para mejorar los resultados obtenidos por el algoritmo goloso del punto anterior. Es decir, dado un tipo de entrada, que en este caso se corresponde con un mapa de pokeparadas y gimnasios, que tendrá alguna particularidad que hará que el algoritmo goloso produzca un resultado bueno o malo, veremos que tipo de busqueda local será mejor aplicar para mejorar la solución o si no conviene aplicar ninguna de las heuristicas de este punto ya que a pesar de ser la solución buena o mala, no se obtienen mejores resultados.

Primero veremos los pseudocodigos de las tres heuristicas y analizaremos sus complejidades. Luego realizaremos un análisis cualitativo de las mismas aplicadas a los resultados de cada tipo de entrada, tratando de abordar las carácteristicas de las mismas y explicar porque una heuristica resulta mejor o no en cada caso. Luego compararemos los mejores resultados y si es posible haremos un análisis para determinar si podría haberse obtenido una solución mejor intercambiando más aristas.
