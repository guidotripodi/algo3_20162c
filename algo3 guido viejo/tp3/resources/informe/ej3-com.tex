

Esta información la podemos obtener en O(1), y pintar un nodo del \textbf{"mejor color"} que a su vez, modifica las restricciones de sus vecinos. Se realiza en complejidad O($\#$vecinos del nodo) asumiendo que el agregar/eliminar/modificar es O(1) en tablas de hash.\\

	 El algoritmo recorre todos los vértices, tomando siempre el menor de la estructura de datos antes mencionada y a cada uno de ellos lo pinta del \textbf{"mejor color"}. Despues, actualiza a los vecinos en la estructura de datos.\\
	 Por ende, la complejidad del algoritmo esta atada a la complejidad de la estructura de datos utilizada.\\

	 Nuestra implementación realiza tanto la operación de eliminación del mínimo como la operación de modificación de clave en O(log(tamaño)).\\
	 Entonces, en cada iteración realizamos los siguientes pasos:
	 \begin{itemize}
		\item Se remueve el mínimo de la estructura con un Costo O(log(V)).
		\item Se lo pinta del \textbf{"mejor color posible"} insumiendo O($\#$vecinos), como en el peor caso podría estar conectado con todos sus vecinos, equivale a O(V).
		\item Para cada vecino se actualiza su nueva cantidad de colores posibles o \textbf{"grado de libertad"}. Esto tiene costo logarítmico para cada vecino, lo que equivale a O(V * log(V)).
	 \end{itemize}

	  Si sumamos todos estos items, obtenemos un total de O(E * log(V)) por iteración, como realizamos V iteraciones, el algoritmo resulta \textbf{O(V * V * log(V))} en el peor caso.\\