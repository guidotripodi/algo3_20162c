
Para resolver este ejercicio, la soluci\'on que planteamos utiliza la t\'ecnica algor\'itmica de \textit{backtracking}. La idea es recorrer todas las configuraciones posibles manteniendo la mejor soluci\'on encontrada hasta el momento.\\

Para poder resolver este punto, nos fue de gran utilidad la creacion de una clase la cual denominamos \textit{Escenario} la cual, como la palabra lo indica nos dar\'a entre otras cosas la cantidad de canibales y arqueologos que hay en cada lado, como tambien la cantidad de pares y el parActual. Dicha clase exportar\'a varias funciones como si existe un $faroleroPosible$ y de existir que farolero se enviar\'ia, que par se env\'ia,  y por ultimo la funciones de backtracking que hab\'iamos enunciado.\\

Una vez nombrado nuestra clase ya podemos centrarnos en la explicaci\'on del algoritmo central.\\
Inicialmente, creamos dos booleanos los cuales nos dira si el backtracking realizado tanto para la lampara como para el par es el \'optimo Dichas variables fueron denominadas como $exitoBackPar$ y $exitoBackLampara$. Por lo cual, ambos son inicializados con el valor verdadero. Adem\'as, creamos 3 enteros $sol$, $minimo$ e $i$ los cuales inicializamos con 0,-1 y 0 respectivamente. Y fundamentalmente, creamos una variable del tipo escenario denominada $escenario$ con los valores que recibimos de entrada.\\
Luego, iniciamos la etapa principal de nuestro algoritmo, la cual se desarrolla dentro de un ciclo el cual  valdr\'a cuando los valores de $exitoBackPar$ y $exitoBackLampara$ sean verdaderos. Aqui chequeamos inicialmente si ya pasaron todos las personas (tanto canibales como arquelogos) de haber pasado, chequemos si el tiempo que paso en esta soluci\'on es mejor al m\'inimo que ten\'iamos hasta el momento, de ser as\'i, la contamos como soluci\'on \'optima hasta el momento.\\ 
Siguiendo el algoritmo, chequeamos si el par que esta por pasar posee l\'ampara, si esto es cierto, se selecciona un par y si es un par en el cual el tiempo que le lleva al mismo es el m\'inimo, en ese caso enviamos el par, sino realizamos backtracking al farolero utilizando la funci\'on $backtrackFarolero$ asignando el resultado de este backtracking a $exitoBackLampara$. En el caso que no se tenga la l\'ampara a\'un, se elije un $faroleroPosible$ chequeandose nuevamente si con dicho farolero que se elijio se obtiene el minimo posible en esta ocasi\'on, en caso afirmativo, enviamos el farolero, en caso negativo hacemos backtracking al par con la func\'ion $backtrackPar$ asignando el resultado de este backtracking a $exitoBackPar$.\\

En las funciones $backtrackPar$ y $backtrackFarolero$ lo que realizamos es retroceder 1 paso hacia atras en principio, tomando el par que viajo ultimo y se lo manda devuelta al sector A. llevando con \'el la l\'ampara de vuelta y se resta el tiempo al tiempo total de la rama que se esta evaluando en este momento. En el caso que no haya pasos hacia atras se devolvera falso, sino se realizara el retroceso que mencionamos actualizando las estructuras que implica dicho retroceso y por \'ultimo devolvemos verdadero.\\

Luego, una vez finalizado el ciclo, retornamos el m\'inimo obtenido, el cual ser\'a el \'optimo total.

 