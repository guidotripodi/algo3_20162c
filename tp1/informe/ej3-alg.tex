A continuaci\'on se detalla el pseudo-c\'odigo de la parte principal del algoritmo incluyendo las podas:

for i = 1 to n do
  for w1 = maxW1 down to a[i].weight do
    for w2 = maxW2 down to a[i].weight do
      dp[w1, w2] = max
                   {
                       dp[w1, w2], <- we already have the best choice for this pair
                       dp[w1 - a[i].weight, w2] + a[i].gain <- put in knapsack 1
                       dp[w1, w2 - a[i].weight] + a[i].gain <- put in knapsack 2
                   }



\begin{algorithm}[H]
\caption{Mochilas}
\begin{algorithmic}[1]
\Function{Algoritmo}{\param{in}{Integer}{M}\param{in}{Integer}{N}}{$\ensuremath{\rightarrow}$ \param{out}{S} {Integer} \param{out}{elementos} {List<Integer>}}
\state creo matriz[N][M] \hfill //O(N $\ast$ M)
\while {i < n} \hfill //O(N $\ast$ $M^{3}$)
\state w1 $gets$ maxM1 \hfill //O(1)
\while {w1 < matriz[i][M]} \hfill //O(M)
\state w2 $gets$ maxM2 \hfill //O(1)
\while {w2 < matriz[i][M]} \hfill //O(M)
\state w3 $gets$ maxM3 \hfill //O(1)
\while {w3 < matriz[i][M]} \hfill //O(M)

\endwhile
\endwhile
\endwhile
\endwhile
\state devolver arrayMaximo.size \hfill //O($cantidadElementos$)
\state devolver arrayMaximo \hfill //O($cantidadElementos$)
\EndFunction 
\end{algorithmic}
\hrule
\complejidad{$\sqrt{P}$}
\end{algorithm}
