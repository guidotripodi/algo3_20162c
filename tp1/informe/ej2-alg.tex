\begin{algorithm}[H]
\caption{BALANZA}
\begin{algorithmic}[1]
\Function{Algoritmo}{\param{in}{Integer}{P}}{$\ensuremath{\rightarrow}$ \param{out}{S} {Integer} \param{out}{T} {Integer} \param{out}{arrayI} {List<Integer>} \param{out}{arrayD}{List<Integer>}}
\state i = 0 \hfill //O(1)
\state Recorro desde $3^0$ hasta $3^i$ $\geq$ P  \hfill //O($\sqrt{P}$)
\state equilibrioActual  $\gets$ P \hfill //O(1)
\state creo arrayPesasUtilizadas vacio \hfill //O(1)
\state estaEnNegativo $\gets$ falso \hfill //O(1)
\state pesaActual  $\gets$  {$3^i$} \hfill //O(1)
\state N = equilibrioActual - pesaActual \hfill //O(1)
\while {Terminar = False} \hfill //O($\sqrt{P}$)
\If{N == 0} \hfill //O(1)
\state arrayPesasUtilizadas $\cup$ pesaActual \hfill //O(1)
\state Terminar \hfill //O(1)
\endif
\If{|N| == 1} \hfill //O(1)
\state arrayPesasUtilizadas $\cup$ pesaActual \hfill //O(1)
\state arrayPesasUtilizadas $\cup$ {$3^0$} \hfill //O(1)
\state Terminar \hfill //O(1)
\endif
\If{|N| > 1 $\wedge$ |N| < equilibrioActual} \hfill //O(1)
\state arrayPesasUtilizadas $\cup$ pesaActual \hfill //O(1)
\state i-- \hfill //O(1)
\state equilibrioActual $\gets$ N \hfill //O(1)
\If{N < 0} \hfill //O(1)
\state estaEnNegativo $\gets$  verdadero \hfill //O(1)
\Else
\state estaEnNegativo $\gets$  falso \hfill //O(1)
\endif
\state equilibrioActual $\gets$ |N| \hfill //O(1)
\endif
\If{|N| $\geq$ equilibrioActual} \hfill //O(1)
\state i-- \hfill //O(1)
\endif
\If{estaEnNegativo} \hfill //O(1)
\state pesaActual  $\gets$  {$3^i$} * (-1) \hfill //O(1)
\state pesaUno  $\gets$  {$3^0$} * (-1) \hfill //O(1)
\Else
\state pesaActual  $\gets$  {$3^i$} \hfill //O(1)
\state pesaUno  $\gets$  {$3^0$}  \hfill //O(1)
\endif
\state N = equilibrioActual - pesaActual \hfill //O(1)
\endwhile
\state devolver(armadoBalanza) \hfill //O(1)
\EndFunction 
\end{algorithmic}
\hrule
\complejidad{$\sqrt{P}$}
\end{algorithm}

\begin{algorithm}[H]
\caption{armadoBalanza}
\begin{algorithmic}[1]
\Function{armadoBalanza}{\param{}{}{}}{$\ensuremath{\rightarrow}$ \param{out}{S} {Integer} \param{out}{T} {Integer} \param{out}{arrayI} {List<Integer>} \param{out}{arrayD}{List<Integer>}}
\state creo x = 0 \hfill //O(1)
\while {x < arrayPesasUtilizadas.size} \hfill //O($\sqrt{P}$)
\If{arrayPesasUtilizadas[x] < 0} \hfill //O(1)
\state arrayD $\cup$ arrayPesasUtilizadas[x]*(-1) \hfill //O(1)
\Else
\state arrayI $\cup$ arrayPesasUtilizadas[x] \hfill //O(1)
\endif
\state x-- \hfill //O(1)
\endwhile
\state devolver arrayD.size \hfill //O(1)
\state devolver arrayI.size \hfill //O(1)
\state devolver invertido(arrayD) \hfill //O($\sqrt{P}$)
\state devolver invertido(arrayI) \hfill //O($\sqrt{P}$)
\EndFunction 
\end{algorithmic}
\hrule
\complejidad{$\sqrt{P}$}
\end{algorithm}