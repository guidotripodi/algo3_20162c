Para este problema realizamos un backtracking que recorre todas las maneras de pintar el grafo hasta que encuentra una coloración. Si se recorren todas las coloraciones posibles y no se encuentra ninguna, el algoritmo indica que no hay coloración.\\

El algoritmo elegido, al ser un backtracking, pinta de algún color un nodo y luego llama recursivo para el resto del grafo. Cuando sale de esa llamada recursiva, si esta indica que no pudo resolverto prueba otro color en ese nodo y repite la llamada recursiva. Así hasta quedarse sin opciones. \\

La forma más inocente de realizar este algoritmo es generar todas las coloraciones, y para cada una chequear si no tiene conflictos. Esto claramente no es lo mejor, porque al no estar realizando podas, terminamos evaluando todas las posibilidades. \\
En nuestra solución, realizamos las siguientes podas:
\begin{itemize}
\item Cuando fijamos un color a un nodo, eliminamos ese color como opción a todos sus vecinos. De esta manera, no pasamos por soluciones que generan conflictos antes de terminar de pintar todo el grafo.
\item Cuando fijamos un color a un nodo y alguno de sus vecinos se queda sin opciones, volvemos atras. Cabe aclarar que esta poda no es equivalente a la anterior, ya que en la otra recién descartariamos la solución al intentar colorear el nodo sin opciones.
\item Llamamos "color facil" al color de un nodo tal que no se encuentra entre los colores de sus vecinos ya pintados ni entre las opciones de color de sus vecinos aún no pintados. Si dicho color existe para algun nodo, lo mejor es pintarlo de ese color, ya que no generará nuevos conflictos cuando intentemos pintar los demás nodos. La poda que añadimos al algoritmo equivale a hacer esto mismo, es decir, si el nodo que estamos intentando pintar tiene algún "color fácil", lo pintamos de ese color sin pasar por las demás posibilidades.
\end{itemize}

Por otra parte, una estrategia que decidimos aplicar es pintar en cada paso el nodo con más opciones de colores. Si bien lo más natural parece intentar colorear los nodos con menos opciones, esta estrategia nos permite llegar en menos pasos al caso en que todos los nodos tienen a lo sumo dos opciones, que lo resolvemos en tiempo polinomial con la ayuda del algoritmo del ejercicio 1. \\

En cuanto a la implementación del algoritmo realizamos la manera clásica de implementar un algoritmo de backtracking. Es decir, con llamadas recursivas pasando el estado actual por parámetro. \\
Para la implementación utilizamos las siguientes estructuras:
\begin{itemize}
\item \textit{Graph}: Explicada en la sección de estructuras de datos, permite:
	\begin{itemize}
	\item Colorear un nodo y actualizar los posibles colores de sus vecinos.
	\item Devuelve las opciones actuales de un nodo sin pintar. Complejidad $O(1)$. 
	\end{itemize}
Estas dos operaciones son cruciales para recorrer todas las posibilidades en el backtracking y realizar una de las podas antes explicadas, ya que las "opciones actuales" de un nodo se calculan teniendo en cuenta las restricciones que presentan los nodos vecinos ya pintados.
\item \textit{ValueSortedMap}: Explicada en la sección de estructuras de datos, permite:
	\item Asociar valores a claves.
	\item Darnos la clave con menor valor asociado. 
	\item Dar y eliminar la clave con el mayor valor asociado.
Esta estructura nos sirve para muchas podas y estrategias. Nos indica si hay un nodo sin opciones, nos indica si el problema es reducible al problema 2-ListColoring y nos ayuda a elegir en cada paso el nodo con mayor cantidad de opciones.
\end{itemize}

