A continuaci\'on se detalla el pseudo-c\'odigo de la parte principal del algoritmo:

\begin{algorithm}[H]
\caption{Calculate}
\begin{algorithmic}[1]
\Function{Solve}{\param{in}{Graph}{graph}}
{$\ensuremath{\rightarrow}$ \param{out}{res}{GraphStatus}}
\state GraphStatus graphStatus $\gets$ GraphStatus(graph)
\state ValueSortedMap<Integer, Integer> nodeColorOpts $\gets$ ValueSortedMap<>() 
\state Integer i $\gets$ 0
\For{i < graph.size()}
\state  nodeColorOpts.put(i, graphStatus.getColorOptions(i))
\while{nodeColorOpts $\neq$ <vacio>}
\state Integer node $\gets$ nodeColorOpts.popFirstValueKey()
\state graphStatus.setLocallyBestColor(node)
\state Integer j $\gets$ 0
\state Integer neighbour  $\gets$ 0
\while{j < graph.getNeighbours(node)}
\state neighbour $\gets$ graph.getNeighbours(node)
\If{!graphStatus.isColored(neighbour)}
\state nodeColorOpts.put(neighbour, graphStatus.getColorOptions(neighbour))
\endif
\state j++
\endwhile
\endwhile
\EndFor
\state res $\gets$ graphStatus
\EndFunction 
\end{algorithmic}
\hrule
\complejidad{E * V * log(V)}
\end{algorithm}

La funciÃ³n que encuentra el mejor color en caso de haber para el nodo es la siguiente:\\

\begin{algorithm}[H]
\caption{getLocallyBestColor}
\begin{algorithmic}[1]
\Function{Solve}{\param{in}{Integer}{node}}
{$\ensuremath{\rightarrow}$ \param{out}{res}{Integer}}
\state Map<Integer, Integer> neighboursColorCount $\gets$ new HashMap<>()
\state Integer j $\gets$ 0
\state Integer neighbour  $\gets$ 0
\while{j < graph.getNeighbours(node)}
\state neighbour $\gets$ graph.getNeighbours(node)
\state Integer color $\gets$ nodeColor.get(neighbour)
\If{color $\neq$ Graph.NOT$\_$COLORED$\_$COLOR} 
\state Integer count $\gets$ neighboursColorCount.get(color)
\If{count == NULL} 
\state Integer count $\gets$ 0
\state neighboursColorCount.put(color, count)
\endif
\state neighboursColorCount.put(color, count + 1)
\endif
\state j++
\endwhile
\state bestColor $\gets$ graph.getPossibleColors(node).iterator().next()
\state Integer bestColorCount $\gets$ neighboursColorCount.get(bestColor)
\state j $\gets$ 0
\state color $\gets$ 0
\while{j < graph.getPossibleColors(node)}
\state Integer colorCount $\gets$ neighboursColorCount.get(color)
\If{colorCount == NULL} 
\state colorCount $\gets$ 0
\endif
\If{colorCount < bestColorCount} 
\state bestColorCount $\gets$ colorCount 
\state bestColor $\gets$ color
\endif
\state j++
\endwhile
\EndFunction 
\end{algorithmic}
\end{algorithm}

