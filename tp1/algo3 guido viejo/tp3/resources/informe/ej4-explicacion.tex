En este algorítmo, se desarrollaron heurísticas que buscan mejorar en cada paso una solución obtenida previamente.\\

\subsection{Vecindades}
Se plantearon dos vecindades distintas, donde la segunda se implementó en función de la primera. \\
La primera (\textit{Exercise4B}) que se nos ocurrió, consiste en pasar de una configuración a otra cambiando un nodo de color, siempre y cuando esto reduzca la cantidad de conflictos de la configuración.\\
La segunda (\textit{Exercise4}), inspirada en la anterior, modifica el color de un nodo por el que genere la menor cantidad de conflictos con sus vecinos pintados. Es decir, re-utiliza la definicion antes nombrada de "mejor color".

\subsection{Inicialización}
Para la primera vecindad, decidimos colorear el grafo tomando algun color posible de cada nodo. Para la segunda, en cambio, inicializamos el grafo con la misma lógica con la que nos movemos entre soluciones, es decir, tomamos el color que genere la menor cantidad de conflictos entre los coloreados.

\subsection{Algoritmos e Implementación}

Los algoritmos, al ser de busqueda local, realizan varias pasadas moviendose en cada una a una solución mejor (dependiendo de la vecindad elegida), es decir, van registrando si en la pasada lograron alguna mejora. El algoritmo termina luego de que en alguna pasada no se haya logrado alguna mejora. \\

Al ser los algoritmos muy similares, sus implementaciones lo son. Ambas consisten de un ciclo sobre una variable que indica si se puede seguir mejorando mediante más pasadas. \\

Siendo mas detallistas, se realizan pasadas. Para cada pasada, por cada nodo, se pinta del color que indique alguna de las vecindades elegidas, registrandose a su vez, si en algún momento de la pasada se produjo una mejora en la cantidad de aristas denominadas \textbf{"buenas"}. Si luego de la pasada se registra alguna mejora, se realiza una nueva pasada, de lo contrario, el algoritmo finaliza. (Cabe aclarar que con aristas "buenas" nos referimos a aristas con sus dos nodos de los bordes pintados y con colores distintos).\\

Para la implementación de estos utilizamos la estructura \textit{Graph} que permite setearle el color a un nodo y actualizar los colores posibles para cada nodo. También, soporta una operación que setea a un nodo del "mejor color" necesaria para la implementación del algoritmo de la segunda vecindad. \\

Es posible demostrar que ambos algoritmos terminan. Supongamos que el algoritmo no termina, luego, en cada iteración aumenta la cantidad de \textbf{"aristas buenas"}, lo que implica que la cantidad  posible de éstas no esta acotada. Luego, como la cantidad de aristas buenas es menor a la  cantidad total de aristas, que esta acotada, llegamos a un absurdo, que vino de suponer que el algoritmo no finalizaba.\\

