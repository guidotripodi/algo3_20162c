
\indent Para resolver el problema, primero convertimos el input a una lista de enteros $Diferencias[]$, de modo que para cada $i$ v\'alido, $Diferencias[i]$ representa la distancia entre la estaci\'on $i$ y la estacion $i+1$ (donde la estaci\'on 0 es la capital). El problema as\'i descripto se reduce a conseguir la mayor cantidad de elementos consecutivos de $Diferencias[]$ tal que su suma sea menor o igual a un n\'umero fijo $L \geq 0$ (la longitud del cable).

Para ello, se mantienen dos \'indices sobre la lista, $i, j$ de modo que se cumple siempre $i \leq j$. Sea $n$ la longitud de la lista, y para cada $0 \leq i \leq j \leq n$, sea $sum(i, j)$ la suma de los elementos desde $Diferencias[i]$ hasta $Diferencias[j-1]$, ambos inclusive, con $sum(i, i)=0$. Comenzamos con $i=j=0$.

Siguiendo un algoritmo \textit{greedy}, vamos a buscar en cada paso la mayor cantidad de elementos consecutivos tal que el \'ultimo elemento es el $j$-\'esimo, y la suma de los elementos es menor o iqual que $L$. En cada iteraci\'on, los elementos a considerar son los elementos desde el $i$ hasta el $j-1$, ambos inclusive.

Mantenemos en una variable la cantidad actual de elementos, la suma de los elementos actuales, y la mayor cantidad de elementos conseguidos hasta el momento; los tres inicializados en $0$. Vamos a iterar $j$ sobre los n\'umeros de $1$ a $n-1$, y en cada paso vamos a hacer lo siguiente:

\begin{itemize}
\item
Movemos $j$ un lugar a la derecha. Esto hace que aumentemos en $1$ la cantidad de elementos actuales, y que la suma de los elementos actuales se incremente en $Diferencias[j-1]$. 

\item
Ahora bien, esto puede hacer que  $sum(i, j) > L$. Para mantener la suma menor o igual, lo que hacemos es mover $i$ a la derecha hasta la primera posici\'on $i'$ que cumple que $sum(i', j) \leq L$. Notar que como $sum(j, j) = 0$, tenemos que $i' \leq j$. Por cada posici\'on $i$ en que nos movemos a la derecha, debemos restar $1$ a la cantidad de elementos actuales, y restar $Diferencias[i]$ a la suma de los elementos actuales.
\end{itemize}

Al cabo de cada iteraci\'on, vale que $i\leq j$ y $sum(i, j) \leq L$. Luego, si la cantidad de elementos actuales es mayor o igual que el m\'aximo conseguido hasta ese momento, actualizamos dicho m\'aximo y seguimos con la siguiente iteraci\'on.

Para probar que el algoritmo resuelve el problema, probemos que para cada $j$, luego de la iteraci\'on $j$-\'esima, el \'indice $i$ es el menor tal que $sum(i, j) \leq L$. Para $j=0$, tenemos $i=0$. Supongamos inductivamente que para $0\leq j < n-1$ al cabo de la $j$-\'esima iteraci\'on, el \'indice $i$ es el menor tal que $sum(i, j) \leq L$. Sea $i'$ el \'indice \'optimo para $j+1$. Es claro que $i' \geq i$, pues si $i' < i$ y $sum(i', j+1) \leq L$, entonces $sum(i', j) \leq L$, contradiciendo la minimalidad de $i$. Luego, $i' \geq i$, y como en el algoritmo movemos al indice $i$ hasta el primer \'indice $i'$ tal que $sum(i', j+1) \leq L$, tenemos que al cabo de la iteraci\'on $j+1$ el \'indice izquierdo es \'optimo para el \'indice $j+1$, como quer\'iamos probar.

Resumiendo, hemos demostrado que para todo $j+1$, encontramos el mejor subarray que termina en el indice $j+1$.

Luego, como la mayor cantidad de elementos tal que su suma sea menor o igual que $L$ se alcanza entre dos elementos, y para cada elemento encontramos el \'optimo a izquierda, el m\'aximo que encuentra el algoritmo es efectivamente el m\'aximo del problema, por lo que el algoritmo es correcto.