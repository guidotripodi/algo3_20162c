Para este algoritmo solicitado, creamos una clase especial, la cual denominamos $friendship$, como el nombre lo indica
esta clase sera un par (a,b) donde las mismas son amigas y nos permitira realizar ciertas operaciones como comparaciones con
otro grupo.\\
Ademas, otra clase llamada $GirlFriendship$ donde tendremos el set de $friends$ para cierta $girl$. Y, por ultimo
una clase $result$ con la cual obtendremos la maxima distancia de una lista.\\

Pasando de lleno a la explicacion de nuestro algoritmo, inicialmente, recibimos una lista de GirlFriendship.\\
Chequeamos si los valores recibidos son correctos $girlFriendships $==$ null$ $return \gets ERROR $.\\
Creamos dos sets uno de $girls$ y otro de $friendship$ vacios. Luego, realizamos un for each recorriendo con la variable
$girlFriendship$ la lista recibida como par\'ametro. Vamos obteniendo por cada vuelta del ciclo la girl correspondiente a su i-\'esimo
lugar y agregandola a nuestro set de $girls$. A su vez, tambien realizamos otro for each dentro en el cual recorremos con la variable
$friend$ el set de amigos correspondiente a la $girls$ del i-\'esimo lugar en el cual estamos parados. Y lo vamos agregando
a nuestro set de $friendship$ al par $(girl$, $friend)$ y tambien al set de $girls$.\\
Luego de esto, fuera de ambos ciclos, creamos una $bestRoundCalculator$ con el par de set de $girls$ y $friendship$ obtenido y realizamos
la operacion calculate y devolvemos dicho valor.\\

A continuaci\'on comentaremos la clase $bestRoundCalculator$ con la cual realizamos las operaciones de c\'alculo, ordenamiento
y m\'axima distancia.\\

Dicha clase, recibe un set de $girls$ y uno de $friendship$ y contar\'a ademas con una lista denominada $bestRound$ y dos enteros $currentMin$
y $currentSum$.

Como habiamos mencionado anteiormente, realizamos la operaci\'on calculate del $bestRoundCalculator$, esta funci\'on realiza un sort del
set de $girls$ recibido como par\'ametro. Luego realizamos una recursi\'on con una funci\'on privada llamada ``calculate'' a la cual
le pasamos un 1. Luego de esto, retornamos el valor que obtenemos entre la funci\'on $getMaxDistance$ y la variable $bestRound$.\\

En la funci\'on privada $"calculate"$  chequeamos si el entero recibido como parametro es igual al tamaño de set $girls$ en caso
de serlo, chequeamos si el entero $currentSum$ es menor a $currentMin$, si esto es correcto, guardamos en $bestRound$ el array de $girls$.
De lo contrario, guardamos en $bestRound$ un array ordenado lexicograficamente entre el array de $girls$ y $bestRound$. Este
orden lo realizamos por medio de la funci\'on $firstLexicographically$.\\
En caso que el entero recibido no sea igual al tamaño de $girls$ realizamos un for desde el entero recibido como par\'ametro
hasta el tamaño de $girls$. Aqu\'i dentro, iremos haciendo swap entre los elementos de $girls$ calculando a su vez, distancias
parciales y guardando los resultados en $currentSum$. \\
Chequeamos si $currentSum$ es menor o igual a $currentMin$, y aqu\'i es donde realizamos la recursi\'on llamando a "calculate" pasandole
el entero recibido + 1. Siguiente a esto, realizamos otro swap y restamos a $currentSum$ el valor parcial de la distancia.\\

En la funci\'on $getMaxDistance$ realizamos dos for anidados,en donde trabajamos con los $friendship$ contando las "amistades" y
sacando la maxima distancia del par.\\

Para una mejor visualizaci\'on mostraremos un pseudocodigo de la funcion privada $"calculate"$ y $getMaxDistance$.\\

\begin{algorithm}[H]
\caption{Calculate}
\begin{algorithmic}[1]
\Function{A}{\param{in}{currentIdx}{Integer}}{$\ensuremath$}
\If{currentIdx == girls.size()} \hfill //O(1)
\If{currentSum < currentMin} \hfill //O(1)
\state bestRound $\gets$ List<Integer>(girls) \hfill //O(e)
\Else
\state bestRound $\gets$ List<Integer>(firstLexicographically(bestRound, girls)) \hfill //O(e)
\endif
\state currentMin $\gets$ currentSum \hfill //O(1)
\Else
\state \textbf{for} (int swapIdx = currentIdx; swapIdx < girls.size(); swapIdx++) \hfill // O(e)
\state \indent Collections.swap(girls, currentIdx, swapIdx) \hfill O(???)
\state \indent Integer partialDistance $\gets$ getPartialDistance(currentIdx) \hfill O(??)
\state  \indent currentSum $\gets$ currentSum + partialDistance \hfill O(1)
  \indent \If{currentSum <= currentMin} \hfill //O(1)
\state  \indent \indent calculate(currentIdx + 1) 
 \indent \endif
\state  \indent Collections.swap(girls, currentIdx, swapIdx) \hfill O(???)
\state  \indent currentSum $\gets$ currentSum - partialDistance \hfill O(1)
\state \textbf{end for}
\endif


\EndFunction 
\end{algorithmic}
\hrule
\complejidad{$e^e$}
\end{algorithm}

\begin{algorithm}[H]
\caption{getMaxDistance}
\begin{algorithmic}[1]
\Function{A}{$\ensuremath{\rightarrow}$ \param{out}{res}{Integer}}
\state maxDistance $\gets$ 0 \hfill //O(1)



\EndFunction 
\end{algorithmic}
\hrule
\complejidad{$e^e$}
\end{algorithm}
