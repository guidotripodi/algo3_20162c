\begin{algorithm}[H] %or another one check
 \Fn{tabuSearch()}{
 %     \SetAlgoLined
 $S_o$ es la solución provista por el algoritmo greedy \\
 ConjuntoTabu attributosTabu \hfill O(n) \\ 
 Recorrido mejorSolucion $\leftarrow$ $S_o$ \hfill O(n)\\
 Recorrido  solucionActual $\leftarrow$ $S_o$ \hfill O(n)\\ 
 entero mejorCosto $\leftarrow$ calcularCosto(mejorSolucion) \hfill O(n)\\
 \For{ entero noMejora en $[0, maxNoMejora)$ }{
	 \hfill ciclo: O(costoInicial*maxNoMejora)\\
	Recorrido mejorCandidato \hfill O(1) \\
  	Lista<Arista> aristasModificadas \hfill O(1)\\
  	entero costoMejorCandidato $\leftarrow$ -1 \hfill O(1)\\
  	
	Conjunto<Recorrido, Lista<Arista> > vecindadActual $\leftarrow$ vecindadFiltrada(solucionActual) \hfill O($n^4$)\\
  	
  	\For{par en vecindadActual}{
		\hfill Ciclo: O($n^4$)\\
  		Recorrido candidatoActual $\leftarrow$ par.first \hfill O(n)\\
  		entero costoActual $\leftarrow$ calcularCosto(candidatoActual) \hfill O(n)\\
		costoMejorCandidato  	$\leftarrow$ calcularCosto(mejorCandidatol) \hfill O(n)\\
		
		\If{costoActual < costoMejor $\vee$ (!tabuCount(atributosTabu, candidatoActual) $\wedge$ (costoActual < costoMejorCandidato $\vee$ costoMejorVecino = -1)}{
			\hfill Condicion: O(n)\\
			aristasModificadas $\leftarrow$ par.second \hfill O(1) \\%|par.second|<=4
			mejorCandidato $\leftarrow$ candidatoActual \hfill O(n)\\
		}
  	}  	
	\hfill Total del ciclo: O($n^5$)

	\If{no se encontro mejorCandidato}{
		\hfill Condicion: O(1)\\
		<Recorrido, Lista<Arista> > menosTabu $\leftarrow$ funcionAspiracion(atributosTabu, vecindadActual) 
		\hfill O($n^5*log(TenorTabu)$)\\%
		
		mejorCandidato $\leftarrow$ menosTabu.first \hfill O(n)\\
		aristasModificadas $\leftarrow$ menosTabu.second \hfill O(1)\\
	}  	
	
	costoMejorCandidato = calcularCosto(mejorCandidato); \hfill O(n) \\
	
	solucionActual $\leftarrow$ mejorCandidato \hfill O(n)\\
		
	\If{costoMejorCandidato $<$ mejorCosto}{
		\hfill Condicion: O(1)\\
		mejorSolucion $\leftarrow$ mejorCandidato \hfill O(n)\\
		mejorCosto $\leftarrow$ costoMejorCandidato \hfill O(1)\\
	}\Else{
		noMejora+=1	
	}

   \For{Arista a en aristasModificadas}{
	 	\hfill Ciclo: O(1)\\
	   atributosTabu.push(a) \hfill O(log(TenorTabu))\\
   }
  	
   \While{|atributosTabu| > TenorTabu}{
	   \hfill Ciclo: O(1)\\
	   atributosTabu.pop() \hfill O(TenorTabu)\\
   }

}

devolver mejorSolucion \\

}

Complejidad final: O(cantidad iteraciones maxima * ( $n^5$*log(TenorTabu) + TenorTabu ))

\end{algorithm}

Complejidad final: O(cantidad iteraciones maxima * ( $n^5$*log(TenorTabu) + TenorTabu ))

\begin{itemize}
\item Justificación de la cota de complejidad del ciclo principal: En el peor caso, se repetirán $maxNoMejora$ cantidad de veces $costoInicial$ valores donde $costoInicial$ es la distancia de la solucion a optimizar. El algoritmo finaliza si se producen $maxNoMejora$ cantidad de iteraciones sin mejora.
\item Arista = < Punto a , Punto b >
\item Punto = < entero x, entero y >
\item La función costo total ya fue definida en el apartado del algoritmo del ejercicio 3.
\item La función vecindadFiltrada devuelve una lista de tuplas. Cada tupla posee una de las soluciones vecinas (obtenida a partir de algun movimiento: 2opt, 3opt o swap) y las aristas que se modificaron para llegar a esa solucion. La soluciones han sido previamente "filtradas"; es decir, una solucion solo puede estar en esta lista si es una solucion valida para nuestro problema. Generar vecindades 2opt y swap tiene complejidad O($n^3$), en cambio las vecindades 3opt toman O($n^4$).
	La cantidad de soluciones de cada vecindad esta acotada de la misma manera que sus complejidades. En peor caso, se encontro una solucion valida en cada iteraci\'on.
	%realiza alguna de las busquedas locales vistas en el ejercicio 3 y devuelve además del mejor recorrido, una lista de aristas modificadas en el proceso.
\item La función funcionAspiracion devuelve dada una vecindad y los atributos tabú, el recorrido que menos atributos tabú tenga y además las aristas modificadas para obtener ese recorrido. Implica iterar sobre la vecindad y sobre los atributos tabu. 
\item La funcion tabuCount sirve para decidir si una solucion es tabu o no y cuenta cuantos atributos tabu posee dando de esta manera una medida de que "tan tabu" es una solucion. Se itera por las aristas de la solucion en tiempo lineal.
\item Atributos tabu esta implementado sobre el set proveido por la STL de c++. Se observa una estructura de arbol rojinegro y se mantiene la cantidad de elementos de este por debajo de $TenorTabu$.
\end{itemize}
