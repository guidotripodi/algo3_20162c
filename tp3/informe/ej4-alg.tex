\begin{algorithm}[H] %or another one check
 \Fn{tabuSearch()}{
 %     \SetAlgoLined
 $S_o$ es la solución provista por el algoritmo greedy \\
 ConjuntoTabu attributosTabu \hfill O(n) \\ 
 Recorrido mejorSolucion $\leftarrow$ $S_o$ \hfill O(n)\\
 Recorrido  solucionActual $\leftarrow$ $S_o$ \hfill O(n)\\ 
 entero mejorCosto $\leftarrow$ calcularCosto(mejorSolucion) \hfill O(n)\\
% 0 hasta Cantidad de iteraciones maxima
 \For{ entero en $[0,Cantidad de iteraciones maxima)$ }{
		 Recorrido mejorCandidato \hfill O(1) \\
  	Lista<Arista> aristasModificadas \hfill O(1)\\
  	entero costoMejorCandidato $\leftarrow$ -1 \hfill O(1)\\
  	
	Conjunto<Recorrido, Lista<Arista> > vecindadActual $\leftarrow$ busquedaLocalFiltrada(s) \hfill O(n3)\\%TODO
  	
  	\For{par en vecindadActual}{
		\hfill Ciclo: O(|vecindadActual|)\\%TODO
  		Recorrido candidatoActual $\leftarrow$ par.first \hfill O(n)\\
  		entero costoActual $\leftarrow$ calcularCosto(candidatoActual) \hfill O(n)\\
		costoMejorCandidato  	$\leftarrow$ calcularCosto(mejorCandidatol) \hfill O(n)\\
		
		\If{costoActual < costoMejor $\vee$ (!tabuCount(atributosTabu, candidatoActual) $\wedge$ (costoActual < costoMejorCandidato $\vee$ costoMejorVecino = -1)}{
			\hfill Condicion: O(evaluar TabuCount)\\%TODO
			aristasModificadas $\leftarrow$ par.second \hfill O(1) \\%|par.second|<=4
			mejorCandidato $\leftarrow$ candidatoActual \hfill O(n)\\
		}
  	}  	
  	
	\If{no se encontro mejorCandidato}{
		\hfill Condicion: O(1)\\
		<Recorrido, Lista<Arista> > menosTabu $\leftarrow$ funcionAspiracion(atributosTabu, vecindadActual) \hfill O(?)\\%TODO
		
		mejorCandidato $\leftarrow$ menosTabu.first \\
		aristasModificadas $\leftarrow$ menosTabu.second \\
	}  	
	
	
	solucionActual $\leftarrow$ mejorCandidato \\
		
	\If{costoMejorCandidato $<$ mejorCosto}{
		mejorSolucion $\leftarrow$ mejorCandidato \\
		mejorCosto $\leftarrow$ costoMejorCandidato \\
	}

   \For{Arista a en aristasModificadas}{
   		atributosTabu.push(a) \\
   }
  	
   \While{|atributosTabu| > TenorTabu}{
		atributosTabu.pop() \\
   }

}

devolver mejorSolucion \\

}

\end{algorithm}

\begin{itemize}
\item Arista = < Punto a , Punto b >
\item Punto = < entero x, entero y >
\item La función costo total ya fue definida en el apartado del algoritmo del ejercicio 3.
\item La función busquedaLocal filtrada realiza alguna de las busquedas locales vistas en el ejercicio 3 y devuelve además del mejor recorrido, una lista de aristas modificadas en el proceso.
\item La función funcionAspiracion devuelve dada una vecindad y los atributos tabú, el recorrido que menos atributos tabú tenga y además las aristas modificadas para obtener ese recorrido
\end{itemize}

