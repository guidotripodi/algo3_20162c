\begin{algorithm}[H] %or another one check
 \Fn{tabuSearch()}{
 %     \SetAlgoLined
 $S_o$ es la solución provista por el algoritmo greedy \\
 ConjuntoTabu attributosTabu \hfill O(n) \\ 
 Recorrido mejorSolucion $\leftarrow$ $S_o$ \hfill O(n)\\
 Recorrido  solucionActual $\leftarrow$ $S_o$ \hfill O(n)\\ 
 entero mejorCosto $\leftarrow$ calcularCosto(mejorSolucion) \hfill O(n)\\
% 0 hasta Cantidad de iteraciones maxima
 \For{ entero en $[0,Cantidad de iteraciones maxima)$ }{
	 \hfill Ciclo: O(Cantidad de iteraciones maxima)\\
	Recorrido mejorCandidato \hfill O(1) \\
  	Lista<Arista> aristasModificadas \hfill O(1)\\
  	entero costoMejorCandidato $\leftarrow$ -1 \hfill O(1)\\
  	
	Conjunto<Recorrido, Lista<Arista> > vecindadActual $\leftarrow$ busquedaLocalFiltrada(s) \hfill O($n^4$) en peor caso al usar 3opt\\
  	
  	\For{par en vecindadActual}{
		\hfill Ciclo: O(|vecindadActual|)\\%TODO
  		Recorrido candidatoActual $\leftarrow$ par.first \hfill O(n)\\
  		entero costoActual $\leftarrow$ calcularCosto(candidatoActual) \hfill O(n)\\
		costoMejorCandidato  	$\leftarrow$ calcularCosto(mejorCandidatol) \hfill O(n)\\
		
		\If{costoActual < costoMejor $\vee$ (!tabuCount(atributosTabu, candidatoActual) $\wedge$ (costoActual < costoMejorCandidato $\vee$ costoMejorVecino = -1)}{
			\hfill Condicion: O(n)\\
			aristasModificadas $\leftarrow$ par.second \hfill O(1) \\%|par.second|<=4
			mejorCandidato $\leftarrow$ candidatoActual \hfill O(n)\\
		}
  	}  	
  	
	\If{no se encontro mejorCandidato}{
		\hfill Condicion: O(1)\\
		<Recorrido, Lista<Arista> > menosTabu $\leftarrow$ funcionAspiracion(atributosTabu, vecindadActual) \hfill O(?)\\%O(|vecindadActual|*n)
		
		mejorCandidato $\leftarrow$ menosTabu.first \hfill O(n)\\
		aristasModificadas $\leftarrow$ menosTabu.second \hfill O(1)\\
	}  	
	
	
	solucionActual $\leftarrow$ mejorCandidato \hfill O(n)\\
		
	\If{costoMejorCandidato $<$ mejorCosto}{
		\hfill Condicion: O(1)\\
		mejorSolucion $\leftarrow$ mejorCandidato \hfill O(n)\\
		mejorCosto $\leftarrow$ costoMejorCandidato \hfill O(1)\\
	}

   \For{Arista a en aristasModificadas}{
	 	\hfill Ciclo: O(1)\\
	   atributosTabu.push(a) \hfill O(log(n))\\
   }
  	
   \While{|atributosTabu| > TenorTabu}{
	   \hfill Ciclo: O(1)\\
	   atributosTabu.pop() \hfill O(log(n)) \\
   }

}

devolver mejorSolucion \\

}

\end{algorithm}

\begin{itemize}
\item Arista = < Punto a , Punto b >
\item Punto = < entero x, entero y >
\item La función costo total ya fue definida en el apartado del algoritmo del ejercicio 3.
\item La función busquedaLocal filtrada realiza alguna de las busquedas locales vistas en el ejercicio 3 y devuelve además del mejor recorrido, una lista de aristas modificadas en el proceso.
\item La función funcionAspiracion devuelve dada una vecindad y los atributos tabú, el recorrido que menos atributos tabú tenga y además las aristas modificadas para obtener ese recorrido
\item La funcion tabuCount sirve para decidir si una solucion es tabu o no y cuenta cuantos atributos tabu posee dando de esta manera una medida de que "tan tabu" es una solucion. Se itera por las aristas de la solucion en tiempo lineal.
\end{itemize}

