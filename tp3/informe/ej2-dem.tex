Nuestro algoritmo va chequeando en cada paso si existe alg\'un gimnasio capaz de ser vencido y, si existe, busca cual es el m\'as cercano de estos a ser vencidos, por lo tanto existir\'an casos en los cuales la soluci\'on obtenida para los mismos sea la \'optima pero para algunos no lo ser\'a.

\subsubsection*{Familias con soluci\'on obtenida igual a la \'optima}

%\begin{enumerate}
%\item No se obtiene soluci\'on por no haber las pokeparadas necesarias para ganar en todos los gimnasios.
%\item No se obtiene soluci\'on ya que la capacidad de la mochila no puede contener las pociones necesarias para vencer a un cierto gimnasio.
%\item Todos los gimnasios sin necesidad de pociones para ser vencidos.
%\item Las pokeparadas y los gimnasios se reciben en orden de la forma en la cual exista una pokeparada puntual para ir a cada gimnasio
%\end{enumerate}

\begin{center}
\textbf{Familia 1 y 2}
\end{center}

Ambas familias devolveran -1 ya que como se explico anteriomente tanto el greedy como el exacto presentan podas para estos casos sin soluci\'on por lo tanto, su tiempo de ejecuci\'on ser\'a aproximadamente el mismo. \\\\\\\\\\\\\\\\\\\



\begin{figure} 
 \centering
  \subfloat[Familia 1: actua poda 1]{
    \includegraphics[width=0.45\textwidth]{./EJ2/fam1medicion.png}}
       \label{fig:fam1medicion}
  \subfloat[Familia 2: actua poda 2]{
    \includegraphics[width=0.45\textwidth]{./EJ2/fam2medicion.png}}
    \label{fig:fam2medicion}
    \end{figure}


Como se observa en los \'ultimos gr\'aficos, las funciones resultantes para cada familia en ambos algoritmos presentan el mismo tiempo por lo comentando sobre las podas realizadas.

\begin{center}
\textbf{Familia 3}
\end{center}

En este caso, como nuestro greedy chequea si hay alg\'un gimnasio a ser vencido con la cantidad de pociones que se tienen en el momento (se inicia con 0), y como todos necesitan 0, recorre los gimnasios sin necesidad de pasar por las pokeparadas, obteniendo la mejor soluci\'on posible.

A continuaci\'on mostraremos el camino obtenido tanto para el algoritmo exacto como el goloso de un caso el cual trabaja con 8 elementos en total para ejemplificar lo enunciado anteriormente:

   \vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.40]{./EJ2/todos0.png}
\\{\textit{Punteado = resultado exacto, contínua = resultado goloso}}
  \end{center}
  \vspace*{0.3cm}

Como se observa en el ejemplo el camino obtenido es exactamente el mismo.


\begin{center}
\textbf{Familia 5}
\end{center}

Se obtendr\'a la soluci\'on \'optima ya que, se reciben primero pokeparadas para vencer a un gimnasio cerca de ellas y luego m\'as pokeparadas para vencer a otros gimnasios que se encuentren cerca de estas \'ultimas, se mostrar\'a a continuaci\'on un dibujo que ejemplifica lo dicho:

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.30]{./EJ2/optima.jpeg}
\\{\textit{Punteado = resultado exacto, contínua = resultado goloso}}
  \end{center}
  \vspace*{0.3cm}

\subsubsection*{Familia con soluci\'on no \'optima}

\begin{center}
\textbf{Familia 4}
\end{center}

Este estilo de familia se elabora de la forma en la cual existan gimnasios que no necesiten pociones para ser vencidos y otros que si. Nuestro algoritmo como por cada iteraci\'on chequea si puede elegir un gimnasio que se encuentre a una distancia m\'inima en relaci\'on a los demas, y adem\'as corrobora si posee las pociones necesarias para vencerlo, decide inicialmente ir a vencer a los gimnasios que posean cero poder, lo cual puede no ser \'optimo para el resultado final.

Debido al poder de computo, el algoritmo exacto solo puede tomar entre 20 o 25 elementos (dependiendo el tipo de instancia), mientras que el goloso puede tomar una mayor cantidad de elementos. Es por esto que se realizaron las comparaciones con la cantidad de elementos soportadas por el exacto.

Este es un ejemplo de ambos algoritmos con un total de 10 elementos:



\begin{figure} [!ht]
 \centering
  \subfloat[Algoritmo exacto]{
    \includegraphics[width=0.45\textwidth]{./EJ2/fam5exacto.png}}
       \label{fig:fam5exacto}
  \subfloat[Algoritmo goloso]{
    \includegraphics[width=0.45\textwidth]{./EJ2/fam5goloso.png}}
    \label{fig:fam5goloso}
    \end{figure}



En base a esta familia y el poder de cómputo, la diferencia (error) entre la soluci\'on obtenida del goloso y la \'optima para cada instancia se puede observar en el siguiente gráfico:

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.5]{./EJ2/algungym0.png}

  \end{center}
  \vspace*{0.3cm}


\begin{center}
\textbf{Familia 6}
\end{center}

Este estilo de familia presenta a los gimnasios y pokeparadas desordenados en referencia a las posiciones, es decir, para ganar a cierto gimnasio es necesario pasar por una cantidad puntual de pokeparadas las cuales estan de un lado y del otro de dicho gimnasio.



\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
 \includegraphics[width=0.75\textwidth]{./EJ2/caminosinorden1.png}
\\{\textit{Camino de solución exacta }}
   
  \end{center}
  \vspace*{0.3cm}


\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
    \includegraphics[width=0.75\textwidth]{./EJ2/caminosinorden.png}
\\{\textit{Camino de solución golosa }}
   
  \end{center}
  \vspace*{0.3cm}

Se puede observar en el ejemplo como nuestro algoritmo goloso va a la primer pokeparada y de ah\'i a vencer al gimnasio m\'as cercano en vez de ir a la pokeparada consecutiva. Esto lo hace hasta vencer a todos los gimnasios.

A continuaci\'on mostraremos para cada instancia posible de ser comparada el error obtenido en cada soluci\'on:

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.60]{./EJ2/sinOrden.png}
  \end{center}
  \vspace*{0.3cm}
  
\begin{center}
\textbf{Familia 7}
\end{center}

Esta familia se genera agrupando los gimnasios y pokeparadas en 2 anillos de radios diferentes. Dado que nuestro algoritmo siempre y cuando pueda vencer a alg\'un gimnasio buscará el m\'inimo en  distancia para vencerlo, para esta familia resulta contraproducente: es preferible adquirir m\'as pociones para luego ir a varios gimnasios juntos, que ganar apenas se pueda.\\\\\\\\\\\\\\\
\vspace*{0.3cm} \vspace*{0.3cm}
\begin{figure} [!ht]
 \centering
  \subfloat[Algoritmo exacto]{
    \includegraphics[width=0.45\textwidth]{./EJ2/anilloexacto.png}}
       \label{fig:anilloexacto}
  \subfloat[Algoritmo goloso]{
    \includegraphics[width=0.45\textwidth]{./EJ2/anillogoloso.png}}
    \label{fig:anillogoloso}
    \end{figure}
\vspace*{0.3cm} \vspace*{0.3cm}

Mostraremos para cada instancia posible de ser comparada el error obtenido en cada soluci\'on:

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.40]{./EJ2/anillosdif.png}
  \end{center}
  \vspace*{0.3cm}

Se puede observar en el \'ultimo gr\'afico como los resultados tienen valores diversos para casos pequeños. En las instancias de mayor tamaño, las solución óptima resulta de recorrer primero todas las pokeparadas y luego los gimnasios, ya que la cantidad de pociones necesarias para vencer a todos los gimnasios es igual a la cantidad total de pociones presentes en el mapa, sumado a que la distancia entre pokeparadas es muy inferior que entre pokeparadas y gimnasios.
No obstante, esto último no se respeta en los casos pequeños, resultando de esta forma el camino óptimo en una alternancia entre pokeparadas y gimnasios.

A continuacion, mostraremos la instancia con 10 elementos para ejemplificar lo comentado:\\\\\\\\\\\\\\\\\

\begin{figure} [!ht]
 \centering
  \subfloat[Algoritmo exacto]{
    \includegraphics[width=0.45\textwidth]{./EJ2/anilloexactoerror.png}}
       \label{fig:anilloexactoerror}
  \subfloat[Algoritmo goloso]{
    \includegraphics[width=0.45\textwidth]{./EJ2/anillogolosoerror.png}}
    \label{fig:anillogolosoerror}
    \end{figure}
    
La instancia con 6 elementos presenta un caso similar.
  
Por \'ultimo, la familia sin soluci\'on \'optima n\'umero 8 la cual es random.\\\\


\begin{figure} [!ht]
 \centering
  \subfloat[Algoritmo exacto]{
    \includegraphics[width=0.45\textwidth]{./EJ2/randomexacto.png}}
       \label{fig:randomexacto}
  \subfloat[Algoritmo goloso]{
    \includegraphics[width=0.45\textwidth]{./EJ2/randomgoloso.png}}
    \label{fig:randomgoloso}
    \end{figure}

Comparemos para cada instancia posible, el error obtenido: \\\\

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.40]{./EJ2/randomdif.png}
\\{\textit{Error por cantidad de elementos }}
  \end{center}
  \vspace*{0.3cm}
  

Luego de lo comentado mostraremos dos gr\'aficos con los errores producidos por cada familia en la soluci\'on obtenida.

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.60]{./EJ2/box1.png}
\\{\textit{Familia 5 y 6 error de solucion}}
  \end{center}
  \vspace*{0.3cm}
  
\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.60]{./EJ2/box2.png}
\\{\textit{Familia 7 y 8 error de solucion}}
  \end{center}
  \vspace*{0.3cm}
  
En conclusi\'on, la soluci\'on obtenida distará tanto de la óptima como la cantidad de veces que el algoritmo recorra una pokeparada y luego un gimnasio a vencerlo, sin importar si lo optimo era pasar primero por las pokeparadas juntando poder y luego visitar varios gimnasios consecutivamente venciendolos a todos.
El peor caso será cuando el mapa sea un anillo de pokeparadas con un anillo interno o externo de gimnasios. 
El algoritmo iniciará en una pokeparada, luego irá a ganar a un gimansio con distancia mínima dentro de los gimansios no visitados, y siguiendo este recorrido, volverá a una pokeparada que se encuentre a una distancia menor de la pokeparada previa.\\

Posteriormente, veremos como se comporta cada familia en funci\'on del tiempo al ir aumentando la cantidad de elementos manteniendo las condiciones para que sigan perteneciendo cada uno a su respectiva familia.

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.60]{./EJ2/comparativo.png}
\\{\textit{Tiempo de ejecución entre familias}}
  \end{center}
  \vspace*{0.3cm}
  \begin{figure} [!ht]
 \centering
  \subfloat[Detalle sin la familia 6]{
    \includegraphics[width=0.45\textwidth]{./EJ2/comparativo1.png}}
    \label{fig:comparativo1}
  \subfloat[Detalle de las familias menos costosas]{
    \includegraphics[width=0.45\textwidth]{./EJ2/comparativo2.png}}
    \label{fig:comparativo2}
    \end{figure}
  
Se puede observar como la familia n\'umero 6 presenta una peor performance en comparaci\'on al resto mientras que tanto la familia 1 como la 2 presentan un tiempo que se torna constante dando una mejor performance en relaci\'on al resto, lo cual se debe a las podas utilizadas para estas familias como mencionamos anteriormente. Mientras que la n\'umero 6 presenta la dificultad en la cual todos los elementos del mapa se encuentran desordenados, por lo tanto nuestro algoritmo tiene que llegar a hacer hasta un doble viaje para poder vencer a un gimnasio, ya que se dan instancias en las cuales los gimnasios de poder menor o igual a 3 se encuentran muy lejos de las pokeparadas en relaci\'on a los gimnasios de poder mayor los cuales estan "pegados" a las pokeparadas insumiendole as\'i un tiempo mayor de decisi\'on y ejecuci\'on. Como hab\'iamos visto, nuestro algoritmo siempre que puede vencer a un gimnasio va a vencerlo.

Luego, mostraremos como se comporta nuestro algoritmo en base a la complejidad calculada anteriormente:

\vspace*{0.3cm} \vspace*{0.3cm}
  \begin{center}
\includegraphics[scale=0.60]{./EJ2/mejorcaso.png}
\\{\textit{Tiempo de ejecución entre familias}}
  \end{center}
  \vspace*{0.3cm}
  
  
Es posible observar como las funciones resultantes del mejor y peor caso se encuentran por debajo de la cota de complejidad. Dicha complejidad fue calculada utilizando el m\'etodo de cuadrados m\'inimos generandonos una funcion la cual tomamos como cota dentro de nuestro orden de complejidad $(O(n+m)^3)$.